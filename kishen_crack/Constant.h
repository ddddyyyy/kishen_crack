#pragma once
#include <cstdint>

/// 加密密钥
const unsigned char key[32] = {
0xBE,0x28,0x02,0xAD,0x5E,0x91,0xDD,0x8E,0x26,0xEA,0xD6,0xB1,0x61,0xFE,0xDB,0x8A,
0x17,0xE2,0x36,0x2F,0x53,0x33,0x6D,0x1B,0x17,0xD8,0x0A,0xE9,0x55,0xC0,0x5A,0xED
};

//const unsigned char key[32] = {
//0x96,0x2C,0x5F,0x3A,0x78,0x9C,0x84,0x37,0xB7,0x12,0x12,0xA1,0x15,0xD6,0xCA,0x9F,0x9A,0xE3,0xFD,0x21,0x0F,0xF6,0xAF,0x70,0xA8,0xA8,0xF8,0xBB,0xFE,0x5E,0x8A,0xF5
//};

const int SEGMENT_SIZE = 0x10010; //分片的最长长度，由于aes的补位 2的16次方加16
const int MAX_SEGMENT_FILE_SIZE = 0x10000; //文件最大的分片大小 2的16次方

//解封包操作返回结果
enum Result
{
	OK,
	COMPRESS_FAIL,
	OPEN_FILE_FAIL,
	CREATE_DICT_FAIL,
	UNPACK_ERROR_SIZE
};

typedef struct segment {
	uint64_t offset;//文件在封包的偏移
	uint32_t seg_size;//区段在封包的大小
	uint32_t seg_ualg_size;//区段未经对齐的大小
	uint32_t seg_ucmp_size;//区段未经压缩的大小
}Segment;

typedef struct file
{
	uint16_t name_len;
	char* name;
	char check[32];//校验值32字节
	uint32_t seg_count;//该文件包含多少个区段
	uint32_t uncomp_size;//文件未压缩之前的大小
	Segment* segments;
} File;